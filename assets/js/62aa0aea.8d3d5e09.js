"use strict";(self.webpackChunktailcall_run=self.webpackChunktailcall_run||[]).push([[2800],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},h="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},u=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(n),u=a,m=h["".concat(l,".").concat(u)]||h[u]||p[u]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:a,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2940:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={title:"Problem Statement",sidebar_position:2,slug:"/"},r=void 0,s={unversionedId:"intro/introduction",id:"intro/introduction",title:"Problem Statement",description:"There are two things that are happening in the tech ecosystem nowadays:",source:"@site/docs/intro/introduction.md",sourceDirName:"intro",slug:"/",permalink:"/docs/",draft:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/intro/introduction.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Problem Statement",sidebar_position:2,slug:"/"},sidebar:"tutorialSidebar",previous:{title:"Test",permalink:"/docs/getting_started/test"},next:{title:"Architecture",permalink:"/docs/intro/architecture"}},l={},c=[{value:"Microservice Architecture",id:"microservice-architecture",level:2},{value:"API Composition",id:"api-composition",level:2},{value:"Composition on Clients",id:"composition-on-clients",level:2},{value:"1. Increased Complexity",id:"1-increased-complexity",level:3},{value:"2. Reduced Performance",id:"2-reduced-performance",level:3},{value:"3. Increased Risk",id:"3-increased-risk",level:3},{value:"Backend For Frontend (BFF)",id:"backend-for-frontend-bff",level:2},{value:"1. Highly Specialized",id:"1-highly-specialized",level:3},{value:"2. Fragile",id:"2-fragile",level:3},{value:"3. Speculative Performance",id:"3-speculative-performance",level:3},{value:"4. Monolith",id:"4-monolith",level:3},{value:"5. Canary Support (Lack thereof)",id:"5-canary-support-lack-thereof",level:3},{value:"6. Coupled Release",id:"6-coupled-release",level:3},{value:"7. Legacy Gateway",id:"7-legacy-gateway",level:3},{value:"8. Organizational Friction",id:"8-organizational-friction",level:3}],d={toc:c},h="wrapper";function p(e){let{components:t,...o}=e;return(0,a.kt)(h,(0,i.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"There are two things that are happening in the tech ecosystem nowadays:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Rich User Interfaces:")," Responsive websites that worked on desktop and mobile are dead. To build a successful B2C business, you need to build for all three platforms viz. Android, iOS, and Web (Desktop/PWA). The applications need to look slick, rich in information and have snappy response times."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Microservice Proliferation:")," Companies these days bootstrap themselves on microservices instead of monoliths. This is because the tooling has gotten a lot better, and reusable components are available either in open-source or as a SAAS solution. This allows developers to focus on their core business logic and move fast.")),(0,a.kt)("h2",{id:"microservice-architecture"},"Microservice Architecture"),(0,a.kt)("p",null,"This is what a typical microservices architecture looks like:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Microservice Architecture Diagram",src:n(4221).Z,width:"3014",height:"2260"})),(0,a.kt)("p",null,'The clients (Mobile/Web) make requests to the microservices through an API gateway. An API gateway is a server that acts as a single point of entry for any type of request. It is responsible for routing them to the appropriate backend service and then returning the response from the backend service to the client. An API gateway can also perform tasks such as authentication, rate limiting, and caching. This makes it a useful component in a microservices architecture, where each service has its API and the API gateway acts as the "front door" for clients to access the services.'),(0,a.kt)("h2",{id:"api-composition"},"API Composition"),(0,a.kt)("p",null,"API composition refers to the process of combining multiple APIs to create a new API or a new functionality. This can be done by sending requests to multiple APIs and combining the results, or by creating a new API that acts as a fa\xe7ade for the underlying APIs."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"API Composition is also known as API Orchestration. This is however vastly different from Microservice Orchestration.")),(0,a.kt)("p",null,"For example, consider a scenario where a client application wants to display a timeline of posts with the profile information of each user on a social media platform. In this case, the client can send two separate requests to two different APIs and combines them together as follows:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"First to ",(0,a.kt)("strong",{parentName:"p"},"/posts")," to retrieve recent posts, with the following response:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"type Post {\n  id: ID!\n  title: String!\n  body: String!\n  userId: ID! # Reference to user by it's id.\n}\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Second, with the ",(0,a.kt)("strong",{parentName:"p"},"userId")," from the above post response, make a request to ",(0,a.kt)("strong",{parentName:"p"},"/users")," to retrieve the user's profile information, with the following response:"),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"type User {\n  id: ID!\n  name: String!\n  email: String!\n}\n"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The client can then combine the results from these two APIs to create a single response that contains all the required information. This new response can be considered as the output of the composed API."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-graphql"},"type Post {\n  id: ID!\n  title: String!\n  body: String!\n  user: User! # Reference to the complete user object\n}\n")))),(0,a.kt)("h2",{id:"composition-on-clients"},"Composition on Clients"),(0,a.kt)("p",null,"The composition on the client side remains unstandardised. There is often a problem of over fetching where the client makes a request to get some data, but the server ends up sending more than what\u2019s required on the screen. And under fetching where the client end up making multiple API calls to get relevant data for a particular screen. This, with a modest hardware and in conjunction with flaky network conditions makes the overall solution unreliable and non-performant."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Modest hardware and flaky network conditions on the client side results in poor user-experience.")),(0,a.kt)("h3",{id:"1-increased-complexity"},"1. Increased Complexity"),(0,a.kt)("p",null,"To build a rich user interface, API composition is necessary on the client side. One of the main challenges with API composition on the client side is that it can lead to increased complexity in the client application. This is because the client needs to handle the process of sending requests to multiple APIs and combining the results, which can add to the overall size and complexity of the client code."),(0,a.kt)("h3",{id:"2-reduced-performance"},"2. Reduced Performance"),(0,a.kt)("p",null,"Another challenge with API composition on the client side is that it can result in reduced performance and increased latency. This is because the client needs to make multiple requests to different APIs, which can take more time and result in a slower response from the composed API."),(0,a.kt)("h3",{id:"3-increased-risk"},"3. Increased Risk"),(0,a.kt)("p",null,"In addition, API composition on the client side can also lead to increased security risks. This is because the client needs to handle sensitive information, such as API keys and authentication credentials, which can be vulnerable to attacks if not properly secured. The client doesn't have access to powerful CPUs or a reliable network either. This makes the composition problem even more challenging to implement and manage. It is therefore often more efficient and effective to perform API composition on the server side instead."),(0,a.kt)("h2",{id:"backend-for-frontend-bff"},"Backend For Frontend (BFF)",(0,a.kt)("a",{parentName:"h2",href:"https://tailcall.in/ab#backend-for-frontend"})),(0,a.kt)("p",null,"A BFF layer can help to solve the challenges of API composition by providing a separate backend service that is optimized for each specific frontend client. This can enable the BFF to perform API composition on behalf of the client, which can help to improve the performance and reliability of the composed API. The BFF layer typically sits as a separate component in the overall architecture, between the frontend client and the microservices. It can communicate with both the frontend client and the microservices using well-defined interfaces and protocols, such as REST or gRPC."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"BFF Diagram",src:n(5514).Z,width:"3617",height:"2224"})),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"BFFs can dramatically improve the reliability and performance of the system, there by having a direct impact on user-experience.")),(0,a.kt)("p",null,"The BFF can take advantage of a powerful CPU and access to a fast network to improve the performance and reliability of the composed API. It can also provide added flexibility and control over the composition process. This can make it a useful tool for developers who want to create new APIs by combining the functionality of multiple underlying APIs. However, there are a few challenges with a BFF layer:"),(0,a.kt)("h3",{id:"1-highly-specialized"},"1. Highly Specialized"),(0,a.kt)("p",null,"One of the challenges with using a BFF layer is that it is a highly specialized solution that requires a significant amount of hand-written code. Unlike an API gateway, there is no standard BFF solution that can be deployed out-of-the-box, and each BFF implementation must be custom-tailored to the specific requirements of the frontend client. This lack of standardization and reusability can make the BFF solution more complex and difficult to maintain."),(0,a.kt)("h3",{id:"2-fragile"},"2. Fragile"),(0,a.kt)("p",null,"Another challenge with using a BFF layer is that it can be fragile and susceptible to failure. The BFF solution is dependent on the developers to follow best practices and handle all error scenarios, and if these steps are not taken, the solution can be prone to bugs and performance issues. Additionally, the BFF solution must be thoroughly tested, including performance testing, unit testing, and integration testing, to ensure that it is reliable and performs well in production. This can require significant effort and expertise, and if these steps are not properly followed, the BFF solution can be fragile and prone to failure. Also, it's worth mentioning that a BFF layer is an entry point to all your backend, it going down basically means nothing is accessible for the user so this layer needs to be robust and resilient to exceptions."),(0,a.kt)("h3",{id:"3-speculative-performance"},"3. Speculative Performance"),(0,a.kt)("p",null,"Because BFF layers are typically custom-written for each use case, it can be difficult to predict the performance impact of a small code change. Issues such as unoptimized algorithms, inefficient caching, and unnecessary downstream requests can go unnoticed and only be discovered very late in the development cycle. Typically companies perform thorough benchmarking and load testing before anything goes live. This results in a very high time to market even for minor changes."),(0,a.kt)("h3",{id:"4-monolith"},"4. Monolith"),(0,a.kt)("p",null,"Eventually, this layer turns out to be a big monolith touching every service in your backend. The layer contains a lot of handwritten spaghetti code that's hard to maintain. Onboarding new engineers also become harder and upgrading libraries or architecture gets costlier. Any tiny change requires a full-fledged deployment on your infrastructure."),(0,a.kt)("h3",{id:"5-canary-support-lack-thereof"},"5. Canary Support (Lack thereof)"),(0,a.kt)("p",null,"Every change that happens in the backend requires the deployment of the BFF layer. Any feature that is built on the client also requires changes on the BFF layer. Such frequent changes can not be exposed to 100% of users because the reliability and performance of this system are unknown. A common way to solve this problem is to use ",(0,a.kt)("a",{parentName:"p",href:"https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment"},"Blue-Green")," deployments. This requires additional infrastructure and complex routing mechanisms. First-class support to do canary releases is very important and should be part of a modern BFF layer, however, most companies rely on DevOps for its support."),(0,a.kt)("h3",{id:"6-coupled-release"},"6. Coupled Release"),(0,a.kt)("p",null,"BFF layers can't be deployed independently since they act as a bridge between the clients and the services. Generally, the services need to go live first, and they need to make sure that the change is compatible with the current version of the BFF layer running in production. The interesting problem is in case there is a bug in the microservice and it needs to be reverted, even the BFF layer needs to be reverted. This kind of coupling makes it operationally very expensive to manage."),(0,a.kt)("h3",{id:"7-legacy-gateway"},"7. Legacy Gateway"),(0,a.kt)("p",null,"BFF layers often end up implementing some of the cross-cutting concerns of an API gateway such as rate limiting, authentication, throttling, etc. This makes its purpose quite confusing if we already have an API gateway. Moreover, it's not very clear if we use an API gateway with a BFF layer, where should we place it? Should we place it between the clients and the BFF layer or the BFF layer and the service mesh? These are subjective decisions that each company ends up making as there is no standard way of doing this. However, it's worth mentioning that legacy gateways do introduce a gap that's being attempted to be filled by a BFF layer."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"BFF, Presentation Layer, Facade, Middleware, Frontend Layer, Orchestration Layer, API Adapter \u2014 Are all different nomenclatures used for the same thing.")),(0,a.kt)("h3",{id:"8-organizational-friction"},"8. Organizational Friction"),(0,a.kt)("p",null,"The Backends for Frontend (BFF) pattern, while designed to enhance user experience, introduces undeniable organizational friction. These issues include communication delays that hinder development, incompatible skill-sets and perspective of what a BFF layer should be doing causing inefficiencies, and a diminished sense of ownership affecting the frontend teams' productivity. While one might suggest transferring BFF ownership to frontend teams as a potential solution, it's not a foolproof fix. This shift necessitates an expansion of skill-sets among frontend teams and demands enhanced coordination, presenting its own challenges."),(0,a.kt)("p",null,"At Tailcall, we are fervently committed to resolving this issue. We perceive this intricate conundrum as a compelling fusion of organizational dynamics and technical intricacies. It presents a uniquely riveting challenge that propels us beyond the confines of conventional software development paradigms."))}p.isMDXComponent=!0},5514:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/bff-878ce671177c6fa3e99bf82f002c2b17.svg"},4221:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/microservices-470f369493a95674ec72436df9d40ce3.svg"}}]);